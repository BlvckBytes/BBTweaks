mainCommand:
  noPermission: '{lut.main_prefix} <&c>Dir fehlen die Zugriffsrechte für diesen Befehl!'
  commandUsage: |
    {lut.main_prefix} <&c>Benutzung: /{command_label} <&7>\<
      <&e *for-action="actions" *for-separator={<&7>,<space/>}>{action}</>
    <&7>>
  configReloadSuccess: '{lut.main_prefix} <&a>Die Konfiguration wurde neu geladen.'
  configReloadError: '{lut.main_prefix} <&c>Die Konfiguration konnte nicht erfolgreich neu geladen werden; siehe Konsole!'
  setRdBreakerNoValidItem: '{lut.main_prefix} <&c>Du hältst kein valides Item in der Hand!'
  setRdBreakerMetadata: '{lut.main_prefix} <&a>Dieses Item ist nun als RD-Breaker gekennzeichnet.'
  setRdBreakerPlayersOnly: '{lut.main_prefix} <&c>Dieser Befehl ist nur Spielern zugänglich!'

abSleep:
  thresholdNotYetReached: '<&a>Es sind <&2>{sleeping_count}<&a>/<&2>{threshold_count} <&a>benötigen Spielern im Bett'
  thresholdReached: '<&a>Die Nacht wird durchgeschlafen'

backOverride:
  playersOnly: '{lut.back_prefix} <&c>Dieser Befehl steht nur Spielern zur Verfügung!'
  noPermission: '{lut.back_prefix} <&c>Dir fehlen die nötigen Rechte, um diesen Befehl benutzen zu können!'
  noLastLocation: '{lut.back_prefix} <&c>Es ist noch keine vorherige Position vorhanden!'
  teleportedBack: '{lut.back_prefix} <&7>Du kehrst zur <&a>vorherigen Position <&7>zurück.'

furnaceLevel:
  noLevelsStored: '<&7>[XP] Keine Level gespeichert'
  levelsStored: '<&6>[XP] {old_level} → {new_level} <&7>({next_level_progress}% ↑)'

getUuid:
  noPermission: '{lut.main_prefix} <&c>Du hast keinen Zugriff auf diesen Befehl!'
  commandUsage: '{lut.main_prefix} <&c>Benutzung: /{command_label} \<Name>'
  unknownName: '{lut.main_prefix} <&c>Konnte zum Namen <&4>{name} <&c>keine UUID finden!'
  resultMessage: |
    {lut.main_prefix} <&7>Die UUID von <&a>{name} <&7>ist <&a><u>
      <hover-text value={<&a>Klicke, um die UUID zu kopieren!}>
        <to-clipboard value=`{uuid}`>
          {uuid}
    </u><&7>!

ping:
  noOtherPermission: '{lut.ping_prefix} <&c>Dir fehlen die Zugriffsrechte, um den Ping anderer Spieler einzusehen!'
  noTargetConsoleSender: '{lut.ping_prefix} <&c>Dieser Befehl ist ohne explizitem Namen nur für Spieler verfügbar!'
  targetNotOnline: '{lut.ping_prefix} <&c>Der Spieler <&4>{name} <&c>ist nicht online!'
  pingSelf: '{lut.ping_prefix} <&7>Dein Ping: <&a>{ping}ms'
  pingOther: '{lut.ping_prefix} <&a>{name}''s <&7>Ping: <&a>{ping}ms'

additionalRecipes:
  shapedRecipes:
    light-blocks:
      result: LIGHT
      amount: 1
      shape:
        - AAA
        - ABA
        - AAA
      ingredients:
        A:
          type: GLASS_PANE
        B:
          type: TORCH

unCraft:
  inGameOnly: '{lut.uc_prefix} <&c>Dieser Befehl ist nur für Spieler verfügbar!'
  missingPermission: '{lut.uc_prefix} <&c>Dir fehlt das nötige Recht, um diesen Befehl benutzen zu können!'
  missingPermissionAllMode: '{lut.uc_prefix} <&c>Dir fehlt das nötige Recht, um den all-Modus benutzen zu können!'
  noItemInMainHand: '{lut.uc_prefix} <&c>Du hältst kein Item in deiner Haupthand!'
  unsupportedItem: '{lut.uc_prefix} <&c>Das von dir gehaltene Item wird nicht unterstützt: <&4>{reason}<&c>!'
  choicesScreen: |
    {lut.uc_prefix} <&7>Bitte entscheide dich für ein Rezept mit <&a>/{label} \<Nummer><&7>:<br/>
    <&7 *for-choice="choices" *for-separator={<br/>}>
      - <&a>#{choice.number}<&7>: <&a>{choice.results}
  invalidSelection: '{lut.uc_prefix} <&c>Ungültige Auswahl: <&4>{selection}<&c>!'
  unacceptedSubtraction: '{lut.uc_prefix} <&7>Bitte akzeptiere zuerst die Einbehaltung von <&c>{subtracted_results} <&7>je <&c>{uncraft_unit eq 1 then "" else `{uncraft_unit} `}Stück <&7>mit <&c>-s<&7>!'
  notEnoughItems: '{lut.uc_prefix} <&c>Vom Item <&4><tr key=`{result_key}`/> <&c>werden mindestens <&4>{required_amount} Stück <&c>benötigt; nutze <&4>-r<&c>, um Reduzierungen zu akzeptieren!'
  notEnoughItemsReduced: '{lut.uc_prefix} <&c>Vom Item <&4><tr key=`{result_key}`/> <&c>werden mindestens <&4>{required_amount} Stück <&c>benötigt, da sonst keine Items übrig bleiben würden!'
  droppedItems: '{lut.uc_prefix} <&7>Dein Inventar <&6>ist voll<&7>; droppe Items: <&6>{items}<&7>!'
  noMoreSpace: '{lut.uc_prefix} <&7>Du hast <&6>keinen Platz <&7>mehr im Inventar; <&6>breche vorzeitig ab<&7>!'
  notEnoughSpace: '{lut.uc_prefix} <&c>Du hast nicht genug Platz im Inventar!'
  itemOverview: '<container *for-item="items" *for-separator={<&7>,<space/>}>{item.amount}x <tr key=`{item.key}`/>'
  successfulUnCraft: |
    {lut.uc_prefix} <&7>Das Item <&a><tr key=`{uncrafted_key}`/> <&7>wurde
    <container *if="whole_units_uncraft_count > 0">
      <space/><&a>{whole_units_uncraft_count}x
      <container *if="uncraft_unit neq 1">
        <space/><&7>je <&a>{uncraft_unit} Stück
      </container>
    </container>
    <container *if="len(reduced_amounts) > 0">
      <space/>
      <&7 *if="whole_units_uncraft_count > 0">und </>
      <&a>{len(reduced_amounts)}x reduziert <&7>(<&a *for-amount="reduced_amounts" *for-separator={<&7>,<space/>}>{amount} Stück</><&7>)
    </container>
    <space/><&7>in insgesamt <&a>{results} <&7>zurückentwickelt
    <container *if="subtracted_items"><&7>; einbehalten wurde <&c>{subtracted_items}</container>
    <&7>!
  additionalReasons:
    hasDamage: Das Item ist bereits abgenutzt
    hasName: Das Item hat einen besonderen Namen
    hasLore: Das Item hat Lore-Zeilen
    hasEnchants: Das Item hat Verzauberungen
    hasAttributeModifiers: Das Item hat besondere Attribute
    hasPdcKeys: Das Item hat besondere PDC-Werte gesetzt
    hasInnerItems: Das Item trägt weitere Items in seinem Inventar
    noEntryFound: Es konnte kein Rezepteintrag zu diesem Item gefunden werden
    noReasonGiven: Es steht kein expliziter Grund zur Verfügung
    recoloringRecipe: Das Rezept für dieses Item stellt bloß eine Umfärbung dar
    smithingRecipe: Das Rezept für dieses Item stammt aus dem Schmiedetisch
  typeExclusionRules:
  resultSubtractionRules:
  typeInclusionRules:
  recipeExclusionRules:
  additionalRecipes:
  preferredMaterials:

mechanic:
  noWallSign: '{lut.mechanic_prefix} <&c>Mechaniken werden nur auf Wandschildern unterstützt, da der Befestigungsblock als Ausgangsvermittler gilt!'
  clock:
    minTickPeriod: 4
    noPermission: '{lut.mechanic_prefix} <&c>Dir fehlen die Zugriffsrechte, um eine Clock zu erstellen!'
    periodDurationAbsent: '{lut.mechanic_prefix} <&c>Fehlende Periodendauer in der dritten Zeile des Schildes!'
    periodDurationMalformedExpression: '{lut.mechanic_prefix} <&c>Ungültige Periodendauer-Eingabe: <&4>{input}<&c>!'
    periodDurationNoPositiveInt: '{lut.mechanic_prefix} <&c>Die Periodendauer von <&4>{duration} <&c>ist negativ!'
    periodDurationTooLow: '{lut.mechanic_prefix} <&7>Die Periodendauer von <&c>{duration} <&7>unterschreitet den Minimalwert von <&c>{min_duration}<&7>; falle auf diesen Wert zurück!'
    periodDurationUneven: '{lut.mechanic_prefix} <&c>Die Periodendauer von <&4>{duration} <&c>ist ungerade; Periodendauer = 2 * Umschaltdauer!'
    creationSuccess: |
      {lut.mechanic_prefix} <&7>Die <&a>Clock <&7>bei <&a>{x} {y} {z} <&7>wurde erfolgreich mit einer Periodendauer von <&a>{duration} Ticks <&7>(
        <&a *let-tick_duration="duration">{lut.tick_duration_display}</&a>
      <&7>) erstellt!
    unknownRemainingTime: '{lut.mechanic_prefix} <&c>Keine verbleibende Zeit verfügbar (Clock deaktiviert?).'
    remainingTimeActionBar: |
      <&7>Umschaltung in: <&a>{remaining_time} Ticks <&7>(
        <&a *let-tick_duration="remaining_time">{lut.tick_duration_display}</&a>
      <&7>)
  pulseExtender:
    minSignalLength: 5
    noPermission: '{lut.mechanic_prefix} <&c>Dir fehlen die Zugriffsrechte, um einen Pulse-Extender zu erstellen!'
    signalLengthAbsent: '{lut.mechanic_prefix} <&c>Fehlende Signallänge in der dritten Zeile des Schildes!'
    periodDurationMalformedExpression: '{lut.mechanic_prefix} <&c>Ungültige Signallänge-Eingabe: <&4>{input}<&c>!'
    signalLengthNoPositiveInt: '{lut.mechanic_prefix} <&c>Die Signallänge von <&4>{signal_length} <&c>ist negativ!'
    signalLengthTooLow: '{lut.mechanic_prefix} <&7>Die Signallänge von <&c>{signal_length} <&7>unterschreitet den Minimalwert von <&c>{min_signal_length}<&7>; falle auf diesen Wert zurück!'
    creationSuccess: |
      {lut.mechanic_prefix} <&7>Der <&a>Pulse-Extender <&7>bei <&a>{x} {y} {z} <&7>wurde erfolgreich mit einer Signallänge von <&a>{signal_length} Ticks <&7>(
        <&a *let-tick_duration="signal_length">{lut.tick_duration_display}</&a>
      <&7>) erstellt!
    noRemainingHighTime: '{lut.mechanic_prefix} <&c>Der Ausgang ist aktuell inaktiv!'
    remainingHighTimeActionBar: |
      <&7>Verbleibende An-Dauer: <&a>{remaining_time} Ticks <&7>(
        <&a *let-tick_duration="remaining_time">{lut.tick_duration_display}</&a>
      <&7>)
  magnet:
    noPermission: '{lut.mechanic_prefix} <&c>Dir fehlen die Zugriffsrechte, um einen Magneten zu erstellen!'
    noContainer: '{lut.mechanic_prefix} <&c>Ein Magnet kann nur an einem Behälterblock angebracht werden!'
    allowMultipleSignsPerContainer: true
    existingSign: '{lut.mechanic_prefix} <&c>Am Behälter bei <&4>{x} {y} {z} <&c>befindet sich bereits ein Magnet!'
    visualizationInitialized: |
      {lut.mechanic_prefix} <&7>Die Region des Magnetes bei <&a>{x} {y} {z}
      <container *if="env('predicate')">
        <&7>, mit dem Prädikat<space/>
        <suggest-command value=`{filter_command}`>
          <&a><u>{predicate}
        </suggest-command><&7>,
      </container>
      <space/><&7>wird nun für <&a>{visualization_duration}s <&7>angezeigt!
    signClickedInEditMode: '{lut.mechanic_prefix} <&c>Bitte breche die Bearbeitung im Menü (sneaken) ab, bevor du das Schild editierst!'
    filterSetByLookingCannotEdit: '{lut.mechanic_prefix} <&c>Du kannst das von dir angeschaute Schild nicht bearbeiten!'
    filterSetByLookingNoChanges: '{lut.mechanic_prefix} <&c>Der Filter <&4>{predicate} <&c>ist bereits am Magneten gesetzt!'
    unsetFilterNoneSet: '{lut.mechanic_prefix} <&c>Dieser Magnet hat keinen Filter gesetzt, den du entfernen könntest!'
    filterSetByLookingUnset: '{lut.mechanic_prefix} <&7>Der Filter des Magnetes wurde <&a>entfernt<&7>.'
    alreadyInAnEditSession: '{lut.mechanic_prefix} <&c>Bitte breche die aktuelle Bearbeitung im Menü (sneaken) ab, bevor du ein weiteres Schild editierst!'
    editModeDistanceExceeded: '{lut.mechanic_prefix} <&c>Du hast dich weiter als <&4>{max_distance} <&c>Blöcke vom Magneten bei <&4>{x} {y} {z} <&c>wegbewegt; breche die Bearbeitung ab!'
    editModeInitialized: '{lut.mechanic_prefix} <&7>Die Bearbeitung des Magnetes bei <&a>{x} {y} {z} <&7>wurde <&a>begonnen<&7>; <&a>sneake <&7>jederzeit, um das <&a>Menü <&7>zu öffnen!'
    editModeSaved: '{lut.mechanic_prefix} <&7>Die Bearbeitung des Magnetes bei <&a>{x} {y} {z} <&7>wurde <&a>abgeschlossen<&7>; Änderungen wurden auf das Schild <&a>geschrieben<&7>!'
    editModeSavedNoChanges: '{lut.mechanic_prefix} <&7>Die Bearbeitung des Magnetes bei <&a>{x} {y} {z} <&7>wurde <&a>abgeschlossen<&7>; es wurden <&a>keine Änderungen <&7>vorgenommen!'
    editModeCancelled: '{lut.mechanic_prefix} <&7>Die Bearbeitung des Magnetes bei <&a>{x} {y} {z} <&7>wurde <&a>abgebrochen<&7>!'
    editModeFilterPrompt: '{lut.mechanic_prefix} <&7>Benutze <&a>/mfilter \<Filter><&7>, um den Filter der aktuellen Editierungssitzung zu ändern.'
    editModeFilterEditSuggestion: |
      {lut.mechanic_prefix} <&7>Editiere den Filter mittels <&a>
      <suggest-command value=`{filter_command}`>
        <&a><u>{filter_command}
      </suggest-command><&7>.
    editModeFilterRemoved: '{lut.mechanic_prefix} <&7>Der aktuelle Filter wurde <&a>entfernt<&7>.'
    creationSuccess: '{lut.mechanic_prefix} <&7>Der <&a>Magnet <&7>bei <&a>{x} {y} {z} <&7>wurde erfolgreich erstellt!'
    editModeClickDetectionActionbar: |
      <&7>{lut.parameter_description[current_parameter]}: <&6>{env(current_parameter)}
      <container *if="env(`{current_parameter}_did_exceed_limit`)">
        <space/>
        <&c><i>(Limit)
      </container>
    filterCommandPlayersOnly: '{lut.mechanic_prefix} <&c>Dieser Befehl steht nur Spielern zur Verfügung!'
    filterCommandNoEditSessionAndNoLookedAt: '{lut.mechanic_prefix} <&c>Du befindest dich aktuell in keiner Bearbeitung eines Magnetes und schaust auch auf kein Magnet-Schild!'
    filterCommandFilterSet: '{lut.mechanic_prefix} <&7>Der Filter <&a>{predicate} <&7>in der Sprache <&a>{language} <&7>wurde gesetzt.'
    filterCommandMissingLanguage: '{lut.mechanic_prefix} <&c>Der Befehl <&4>/{label} <&c>erfordert eine Sprachauswahl als ersten Parameter!'
    filterCommandUnknownLanguage: '{lut.mechanic_prefix} <&c>Die Sprache <&4>{input} <&c>stellt keine gültige Auswahl dar; wähle aus: <&4 *for-language="languages" *for-separator={<&c>,<space/>}>{language}</><&c>.'
    filterCommandPredicateError: '{lut.mechanic_prefix} <&c>Ungültiger Filter: <&4>{error}<&c>.'
    filterCommandEmptyPredicate: '{lut.mechanic_prefix} <&c>Bitte gib einen gültigen Filter an!'
    visualizeCommandChunkExpandRadius: 2
    visualizeCommandPlayersOnly: '{lut.mechanic_prefix} <&c>Dieser Befehl steht nur Spielern zur Verfügung!'
    visualizeCommandNoMagnetsNearby: '{lut.mechanic_prefix} <&c>Es befinden sich keine Magnete in deinem Chunk, auf die du Zugriff hast!'
    visualizeCommandVisualizingNearbyMagnets: '{lut.mechanic_prefix} <&7>Zeige <&a>{magnet_count} Magnete <&7>in deiner Umgebung für <&a>{visualization_duration}s <&7>an.'
    editDisplay:
      title: '<&8>Magnet <&e>{magnet_x} {magnet_y} {magnet_z}'
      rows: 2
      items:
        selectParameterExtentX:
          type: '<container +let-name="EXTENT_X">{lut.parameters.type}'
          slots: 1
          name: '<container +let-name="EXTENT_X">{lut.parameters.name}'
          lore: '<container +let-name="EXTENT_X">{lut.parameters.lore}'
        selectParameterExtentY:
          type: '<container +let-name="EXTENT_Y">{lut.parameters.type}'
          slots: 2
          name: '<container +let-name="EXTENT_Y">{lut.parameters.name}'
          lore: '<container +let-name="EXTENT_Y">{lut.parameters.lore}'
        selectParameterExtentZ:
          type: '<container +let-name="EXTENT_Z">{lut.parameters.type}'
          slots: 3
          name: '<container +let-name="EXTENT_Z">{lut.parameters.name}'
          lore: '<container +let-name="EXTENT_Z">{lut.parameters.lore}'
        selectParameterOffsetX:
          type: '<container +let-name="OFFSET_X">{lut.parameters.type}'
          slots: 10
          name: '<container +let-name="OFFSET_X">{lut.parameters.name}'
          lore: '<container +let-name="OFFSET_X">{lut.parameters.lore}'
        selectParameterOffsetY:
          type: '<container +let-name="OFFSET_Y">{lut.parameters.type}'
          slots: 11
          name: '<container +let-name="OFFSET_Y">{lut.parameters.name}'
          lore: '<container +let-name="OFFSET_Y">{lut.parameters.lore}'
        selectParameterOffsetZ:
          type: '<container +let-name="OFFSET_Z">{lut.parameters.type}'
          slots: 12
          name: '<container +let-name="OFFSET_Z">{lut.parameters.name}'
          lore: '<container +let-name="OFFSET_Z">{lut.parameters.lore}'
        filler:
          type: BLACK_STAINED_GLASS_PANE
          name: ' '
          slots: '0..last_slot'
        save:
          type: GREEN_CONCRETE
          slots: 5
          name: '<reset><&8>» <&a>Speichern <&8>«'
          lore: |
            <reset>
              <br/>
              <&7>Schreibt die Änderungen<br/>
              und verlässt den Modus.
        modifyFilter:
          type: '{filter_predicate then "LIME_CONCRETE" else "LIGHT_GRAY_CONCRETE"}'
          slots: 7
          name: '<reset><&8>» <&7><&a *use="filter_predicate">Filter <&8>«'
          lore: |
            <reset>
              <br/>
              {lut.spacer}<br/>
              <container *if="filter_predicate">
                <&8>♦ <&7>Aktueller Filter: <&e>{filter_predicate}<br/>
                <&8>♦ <&7>Filtersprache: <&e>{filter_language}<br/>
                {lut.spacer}<br/>
                <&8>➥ <&e>Linksklick <&7>Filter editieren<br/>
                <container *if="is_floodgate">
                  <&8>➥ <&e>Werfen <&7>Filter entfernen<br/>
                </container>
                <container *else>
                  <&8>➥ <&e>Rechtsklick <&7>Filter entfernen<br/>
                </container>
              </container>
              <container *else>
                <&8>♦ <&7>Aktueller Filter: <&c>kein Filter gesetzt<br/>
                {lut.spacer}<br/>
                <&8>➥ <&e>Linksklick <&7>Filter setzen<br/>
              </container>
              {lut.spacer}
        cancel:
          type: RED_CONCRETE
          slots: 14
          name: '<reset><&8>» <&c>Abbrechen <&8>«'
          lore: |
            <reset>
              <br/>
              <&7>Verwirft die Änderungen<br/>
              und verlässt den Modus.
        toggleClickDetection:
          type: '{click_detection then "LIME_CONCRETE" else "LIGHT_GRAY_CONCRETE"}'
          slots: 16
          name: |
            <reset>
              <&8>»
                <space/>
                <&a *if="click_detection">Klick-Detektion aktiviert</>
                <&7 *else>Klick-Detektion deaktiviert</>
                <space/>
              <&8>«
          lore: |
            <reset>
              <br/>
              <&7>Schalte um, ob Mausklicks außerhalb<br/>
              des Menüs erkannt werden sollen, um<br/>
              den aktuellen Parameter zu verändern.<br/>
              <br/>
              <&e><i>Diese Funktion erfordert, dass du ein<br/>
              beliebiges Item in deiner Hand hältst!
    maxWidthOrDepth: 15
    maxHeight: 30
    collectionPeriodTicks: 5
    defaultWidthAndDepth: 5
    defaultHeight: 5
    defaultOffsetX: -2
    defaultOffsetY: 0
    defaultOffsetZ: -2
    visualization:
      durationMs: 5000
      periodTicks: 5
      stepSize: .1
      dustSize: 1
      editModeMaxXZDistance: 40
      visualizeColor:
        red: 85
        green: 255
        blue: 255
      editColor:
        red: 255
        green: 255
        blue: 85
      editHighlightColor:
        red: 255
        green: 170
        blue: 0

seedOverride:
  playersOnly: '{lut.seed_prefix} <&c>Dieser Befehl steht nur Spielern zur Verfügung!'
  worldSpecificMessages:
    creative: '{lut.seed_prefix} <&7>Der Seed von <&a>Creative <&7>lautet: {lut.seed_display}<&7>.'
    world: '{lut.seed_prefix} <&7>Der Seed der <&a>Bauwelt <&7>lautet: {lut.seed_display}<&7>.'
    world_farm: '{lut.seed_prefix} <&7>Der Seed der <&a>Farmwelt <&7>lautet: {lut.seed_display}<&7>.'
    world_nether: '{lut.seed_prefix} <&7>Der Seed des <&a>Nethers <&7>lautet: {lut.seed_display}<&7>.'
    world_the_end: '{lut.seed_prefix} <&7>Der Seed des <&a>Ends <&7>lautet: {lut.seed_display}<&7>.'
  fallbackMessage: '{lut.seed_prefix} <&7>Der Seed der Welt <&a>{world} <&7>lautet: {lut.seed_display}<&7>.'

customCommands:
  commands:

cLut:
  main_prefix: '<&7>[<&5>BBTweaks<&7>]'
  ping_prefix: '<&7>[<&6>Ping<&7>]'
  uc_prefix: '<&7>[<&6>UC<&7>]'
  back_prefix: '<&7>[<&6>Back<&7>]'
  mechanic_prefix: '<&7>[<&6>Mechanic<&7>]'
  seed_prefix: '<&7>[<&6>Seed<&7>]'
  spacer: |
    <container *if="is_floodgate">
      <&8>{"-" ** 45}
    </container>
    <container *else>
      <&8><&m>{" " ** 55}
    </container>
  parameter_description:
    EXTENT_X: 'Durchmesser in <b><u>X</b>-Richtung'
    EXTENT_Y: 'Durchmesser in <b><u>Y</b>-Richtung'
    EXTENT_Z: 'Durchmesser in <b><u>Z</b>-Richtung'
    OFFSET_X: 'Verschiebung in <b><u>X</b>-Richtung'
    OFFSET_Y: 'Verschiebung in <b><u>Y</b>-Richtung'
    OFFSET_Z: 'Verschiebung in <b><u>Z</b>-Richtung'
  parameters:
    type: '{current_parameter eq name then "ORANGE_CONCRETE" else "GRAY_CONCRETE"}'
    name: '<reset><&8>» <&7><&6 *use="current_parameter eq name">{lut.parameter_description[name]} <&8>«'
    lore: |
      <reset>
        <br/>
        {lut.spacer}<br/>
        <&8>♦ <&7>Aktueller Wert: <&e>{env(name)}
        <container *if="env(`{name}_did_exceed_limit`)">
          <space/>
          <&c><i>(Limit)
        </container>
        <br/>
        {lut.spacer}<br/>
        <container *if="current_parameter eq name">
          <&8>➥ <&e>Linksklick <&7>Parameter verringern<br/>
          <container *if="is_floodgate">
            <&8>➥ <&e>Werfen <&7>Parameter erhöhen<br/>
          </container>
          <container *else>
            <&8>➥ <&e>Rechtsklick <&7>Parameter erhöhen<br/>
          </container>
        </container>
        <container *else>
          <&8>➥ <&e>Linksklick <&7>Parameter auswählen<br/>
        </container>
        {lut.spacer}
  seed_display: |
    <hover-text value={<&a>Klicke, um den Seed zu kopieren!}>
      <to-clipboard value=`{seed}`>
        <&a><u>{seed}
  tick_duration_display: |
    <container *if="tick_duration <= 1">
      sofortig
    </container>
    <container *else-if="tick_duration < 20 * 60">
      <number [value]="double(tick_duration) / 20" format="0.0" locale="de_DE" />s
    </container>
    <container
      *else
      *let-seconds="double(tick_duration) / 20"
    >
      <container *if="floor(seconds) neq seconds">≈</container>
      <duration [value]="ceil(seconds) * 1000" units="hms" />
    </container>
